# 第5章 创建布局

## 第5章的学习从解说视频开始吧

**观看**

本章的前置知识建议学习『HTML篇』和『CSS & Design篇』。

在第4章的简单Ruby之旅中,我们学习了如何在示例应用程序中包含应用程序样式表(4.1)。但是,这个样式表目前还是空的。在本章中,我们将在应用程序中集成Bootstrap框架,并添加自定义样式<sup>1</sup>。同时,我们还会在布局中添加到目前为止创建的页面(如Home和About等)的链接(5.1)。在此过程中,我们将学习局部视图(partial)、Rails的路由和Asset Pipeline,还会介绍Sass(5.2)。在本章的最后,我们将迈出让用户登录网站的重要第一步(5.4)。

本章将专注于为示例应用程序添加和修改布局。对于布局,有些部分我们会使用测试驱动开发,也有完全不写测试的部分(关于何时编写测试和何时不编写测试的指南,请参见专栏3.3)。因此,本章主要通过编辑器修改和浏览器确认来进行。唯一使用测试驱动开发的部分是5.3.1中添加Contact页面的部分。最后,我们将介绍一种新的测试方法——"集成测试(Integration Test)"(5.3.4)。使用集成测试来检查最终布局和链接是否正确。

## 5.1 添加结构

Rails教程是一本关于Web开发的书,而不是Web设计的书,但如果继续使用毫无样式、外观冷清的应用程序进行开发,确实难以提起干劲。因此在本章中,我们将为布局添加一些结构和CSS,添加最基本的样式。除了自定义CSS规则外,我们还将使用作为开源Web设计框架公开的Bootstrap<sup>2</sup>。同时,我们也会为代码本身添加样式。也就是说,使用局部视图(Partial)功能来整理开始变得凌乱的布局代码。

在创建Web应用程序时,尽早掌握用户界面的概要通常是有用的。因此,本书将使用模型图(在Web环境中通常称为线框图),即实现后的应用程序外观的草图<sup>3</sup>。在本章中,我们主要开发包含3.2中介绍的网站logo、导航标题和网站页脚的静态页面。这些页面中最重要的Home页面的模型图如图5.1所示。根据模型图创建的最终结果可以在图5.9中确认。对比两者,你会发现细节略有不同。例如,实际上我们最后会在页面上添加Rails的logo。但模型图不需要完全准确,所以这样就足够了。

<sup>7</sup>**图5.1: 示例应用程序Home页面的模型图**

如果你正在使用Git进行版本控制,像之前一样,现在是创建新分支的好时机。

```bash
$ git switch -c filling-in-layout
```

### 5.1.1 导航

作为第一步,为了向示例应用程序添加链接和样式,我们将在网站的布局文件`application.html.erb`(列表4.3)中添加HTML结构,更新布局文件。此更新包括添加区域(div标签)、添加CSS类、添加作为网站导航起点的区域。完整的文件如列表5.1所示。接下来,我们将解释构成它的许多部分。如果想立即确认显示结果,可以在图5.2中确认(注:此时并不值得特意去看)。

**列表5.1: 添加了结构的网站布局**  
`app/views/layouts/application.html.erb`

```erb
<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>
  <body>
    <header class="navbar navbar-fixed-top navbar-inverse">
      <div class="container">
        <%= link_to "sample app", '#', id: "logo" %>
        <nav>
          <ul class="nav navbar-nav navbar-right">
            <li><%= link_to "Home",   '#' %></li>
            <li><%= link_to "Help",   '#' %></li>
            <li><%= link_to "Log in", '#' %></li>
          </ul>
        </nav>
      </div>
    </header>
    <div class="container">
      <%= yield %>
    </div>
  </body>
</html>
```

那么,让我们从上到下看一下列表5.1中的新元素。Rails默认使用HTML5<sup>4</sup>。在head标签之后的部分包含显示网站logo的header、一些由div标签构成的区域以及导航链接列表。

```html
<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "sample app", '#', id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home",   '#' %></li>
        <li><%= link_to "Help",   '#' %></li>
        <li><%= link_to "Log in", '#' %></li>
      </ul>
    </nav>
  </div>
</header>
```

header标签表示应该位于页面顶部的元素。这个header标签被赋予了三个用空格分隔的CSS类:navbar、navbar-fixed-top和navbar-inverse<sup>5</sup>。

```html
<header class="navbar navbar-fixed-top navbar-inverse">
```

所有HTML元素都可以指定类(class)和id<sup>6</sup>。类和id只是标签,在CSS中指定样式时很方便(5.1.2)。类和id的主要区别在于,类可以在页面中多次使用,而id在页面中只能使用一次。在这种情况下,所有navbar类都被5.1.2中将要安装的Bootstrap框架赋予了特殊含义。

在header标签内部有div标签。

```html
<div class="container">
```

div标签表示一般的显示区域,用于将元素分成不同的部分。特别是在旧式HTML中,div标签几乎在网站的所有区域都被使用。但从HTML5开始,可以针对常用区域进行细分,具体来说可以使用header元素、nav元素、section元素。另外,与header标签的类一样,div标签也被赋予了CSS类(container),这个类在Bootstrap中也具有特殊含义。

在div之后,出现了ERB代码。

```erb
<%= link_to "sample app", '#', id: "logo" %>
<nav>
  <ul class="nav navbar-nav navbar-right">
    <li><%= link_to "Home",   '#' %></li>
    <li><%= link_to "Help",   '#' %></li>
    <li><%= link_to "Log in", '#' %></li>
  </ul>
</nav>
```

这里使用Rails辅助方法`link_to`来生成链接。它会生成3.2.2中看到的锚标签a。`link_to`的第一个参数是链接文本,第二个参数是URL。这个URL将在5.3.3中替换为命名路由(Named Routes),但现在我们先放置Web设计中常用的存根(stub)URL"'#'"。第三个参数是选项哈希,在这种情况下,示例应用程序的链接指定了CSS id logo(其他三个链接没有指定选项哈希,因为它不是必需的,所以没问题)。Rails辅助方法经常接受这样的选项哈希作为参数,这使得可以在不离开Rails代码的情况下灵活地添加任意HTML选项。

div内部的第二个元素是由列表项标签li和无序列表标签ul创建的导航链接列表。

```html
<nav>
  <ul class="nav navbar-nav navbar-right">
    <li><%= link_to "Home",   '#' %></li>
    <li><%= link_to "Help",   '#' %></li>
    <li><%= link_to "Log in", '#' %></li>
  </ul>
</nav>
```

严格来说这里并不需要,但nav标签的作用是明确传达"内部是导航链接"的意图。此外,赋予ul标签的nav、navbar-nav和navbar-right类在Bootstrap中也具有特殊含义。因此,在5.1.2中添加Bootstrap CSS时,这些样式也会自动应用。这可以通过浏览器查看源代码来确认<sup>7</sup>,但当Rails评估ERB并渲染布局时,上面的列表会被替换为以下内容<sup>8</sup>:

```html
<nav>
  <ul class="nav navbar-nav navbar-right">
    <li><a href="#">Home</a></li>
    <li><a href="#">Help</a></li>
    <li><a href="#">Log in</a></li>
  </ul>
</nav>
```

这就是返回给浏览器的HTML。

布局的最后部分是主要内容的div。

```erb
<div class="container">
  <%= yield %>
</div>
```

与上面一样,container类在Bootstrap中也具有特殊含义。如3.4.3中所学,yield方法将每个页面的内容插入到网站布局中。除了将在5.1.3中添加的网站页脚外,布局就完成了。

访问Home页面可以确认显示结果。为了使用未来的样式元素,我们在`home.html.erb`视图中添加一些特殊元素(列表5.2)。

**列表5.2: 带有注册页面链接的Home页面**  
`app/views/static_pages/home.html.erb`

```erb
<div class="center jumbotron">
  <h1>Welcome to the Sample App</h1>
  <h2>
    This is the home page for the
    <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
    sample application.
  </h2>
  <%= link_to "Sign up now!", '#', class: "btn btn-lg btn-primary" %>
</div>

<%= link_to image_tag("rails.svg", alt: "Rails logo", width: "200"),
                      "https://rubyonrails.org/" %>
```

为了在第7章向网站添加用户时做准备,第一个`link_to`生成如下临时链接:

```html
<a href="#" class="btn btn-lg btn-primary">Sign up now!</a>
```

上面提到的div标签的CSS类jumbotron,以及signup按钮的btn类、btn-lg类和btn-primary类,在Bootstrap中都具有特殊含义。

第二个`link_to`展示了`image_tag`辅助方法的功能,它接受图像文件的路径和可选的选项哈希作为参数。这个辅助方法可以使用符号设置alt属性和width属性等。另一方面,为了显示图像,需要添加名为`rails.svg`的Rails logo图像文件。请从Learn Enough网站的 https://cdn.learnenough.com/rails.svg 下载图像,并将其放在`app/assets/images/`目录中。如果使用云IDE或其他类Unix系统,可以使用curl工具完成此操作(列表5.3)<sup>9</sup>。

**列表5.3: 下载图像**

```bash
$ curl -o app/assets/images/rails.svg -L https://cdn.learnenough.com/rails.svg
```

在列表5.2中使用了`image_tag`辅助方法,Rails会通过Asset Pipeline在`app/assets/images/`目录中查找相应的图像文件(Asset Pipeline将在5.2中说明)。

现在,准备工作完成了。根据环境,可能需要在此重启Rails服务器,如有必要请尝试重启(参见专栏1.2)。如果顺利,应该会得到如图5.2所示的结果。

<sup>7</sup>**图5.2: 未使用自定义CSS的Home页面**

为了确认`image_tag`的效果,让我们从浏览器查看生成的HTML<sup>10</sup>:

```html
<img alt="Rails logo" width="200px" src="/assets/rails-<long string>.svg">
```

`<long string>`部分是Rails添加的,用于使文件名唯一。这是一种机制,例如当将图像文件更新为新图像时,故意不让它命中浏览器中保存的缓存。另外,请注意src属性不包含"images"目录名。assets目录中的其他目录(images、javascripts、stylesheets等)也是如此。这是一种加速机制,Rails将assets目录正下方的图像与`app/assets/images`目录中的图像关联起来。这样,从浏览器看,所有文件似乎都在同一个目录中。采用这种扁平的目录结构可以更快地将文件传递给浏览器。

最后,alt属性是在没有图像时显示的替代文本。例如,视障用户使用的屏幕阅读器会读出这个属性,表明那里有图像。

现在,我们准备好确认到目前为止努力的成果了(图5.2)。比预期的简陋吗?可能是的。但是,由于这次我们为HTML元素赋予了合理的类,所以已经进入了可以添加CSS样式的极好状态。

#### 练习

说到网页就是猫图片,Web上充满了猫图片。让我们使用列表5.4中的命令下载图5.3的猫图片<sup>11</sup>。使用mv命令将下载的`kitten.jpg`文件移动到适当的资源目录(参考:5.2.1)。使用`image_tag`显示`kitten.jpg`图像(图5.4)。

<sup>7</sup>**图5.3: Web必备(?)的小猫图像**

**列表5.4: 从互联网下载猫图片**

```bash
$ curl -OL https://cdn.learnenough.com/kitten.jpg
```

<sup>7</sup>**图5.4: 在Home页面上显示小猫图像的结果**

### 5.1.2 Bootstrap和自定义CSS

在5.1.1中,我们将许多HTML元素与CSS类关联起来。这样做可以在构建基于CSS的布局时提供高度的灵活性。如5.1.1所述,这些类中的许多是Twitter创建的框架Bootstrap特有的。Bootstrap是一个CSS框架,可以轻松地为HTML5应用程序添加出色的Web设计和用户界面元素。在本节中,我们将结合使用自定义CSS规则和Bootstrap为示例应用程序添加样式。

值得注意的是,使用Bootstrap可以使应用程序采用响应式设计(Responsive Design)。这使得无论在哪个设备上查看应用程序,都能在一定程度上保持美观。

首先,让我们添加Bootstrap,如列表5.5所示。这可以使用`bootstrap-sass` gem引入Rails应用程序<sup>12</sup>。Bootstrap框架使用LESS CSS语言生成动态样式表,但Rails的Asset Pipeline默认支持Sass语言(与LESS非常相似)(5.2)。因此,`bootstrap-sass`将LESS转换为Sass,并使所有必需的Bootstrap文件在当前应用程序中可用。从Rails 7开始,Asset Pipeline的Sass功能被分离到名为`sassc-rails`的单独gem中(`sassc-rails` gem在列表3.2时已经包含)。

**列表5.5: 在Gemfile中添加Sass的gem**  
`Gemfile`

```ruby
...
gem "rails",           "7.0.4.3"
gem "bootstrap-sass",  "3.4.1"
gem "sassc-rails",     "2.1.2"
gem "sprockets-rails", "3.4.2"
...
```

像往常一样运行`bundle install`安装Bootstrap和Sass。

```bash
$ bundle install
```

顺便说一下,通过运行`rails generate`命令会自动生成按控制器分隔的CSS文件,但由于按正确顺序加载这些文件非常困难,本教程采用将所有CSS合并为一个的方针。

运行自定义CSS的第一步是创建自定义CSS文件。

```bash
$ touch app/assets/stylesheets/custom.scss
```

这里使用了3.3.3中途介绍的touch命令,但如果能创建文件,[新建文件]或其他命令也没问题。这个目录名和文件名都很重要。以下目录是

```
app/assets/stylesheets/
```

Asset Pipeline(5.2)的一部分,放置在此目录中的样式表将作为`application.css`的一部分加载到网站布局中。此外,文件名`custom.scss`包含`.scss`扩展名。这个扩展名称为"Sass(Sassy CSS)",是CSS的扩展语言,Asset Pipeline通过这个文件扩展名来处理Sass(`Sass`在5.2.2才会出现,但作为`bootstrap-sass` gem运行所需的咒语)。

创建自定义CSS文件后,使用`@import`加载Bootstrap及其相关的Sprockets,如列表5.6所示<sup>13</sup>。

**列表5.6: 添加Bootstrap CSS**  
`app/assets/stylesheets/custom.scss`

```scss
@import "bootstrap-sprockets";
@import "bootstrap";
```

列表5.6的两行引入了Bootstrap CSS框架。引入后,重启Web服务器就可以反映到应用程序中。(如1.3.2所介绍,按Ctrl-C停止Web服务器,然后输入`rails server`命令启动Web服务器)。如果顺利,结果应该如图5.5所示。现在,文本对齐还不够好,logo也没有样式,但颜色和signup按钮的感觉已经相当不错了。

<sup>7</sup>**图5.5: Bootstrap CSS和示例应用程序**

接下来,如列表5.7所示,我们将添加CSS来为整个网站的布局和各个页面添加样式。添加后的结果如图5.6所示。列表5.7包含许多描述规则。为了掌握CSS的描述规则,建议注释掉感兴趣的部分并确认显示。在CSS中可以用`/* … */`注释掉,所以用它围住想要检查的代码,看看显示如何变化。

**列表5.7: 向CSS添加应用于所有页面的通用样式**  
`app/assets/stylesheets/custom.scss`

```scss
@import "bootstrap-sprockets";
@import "bootstrap";

/* universal */

body {
  padding-top: 60px;
}

section {
  overflow: auto;
}

textarea {
  resize: vertical;
}

.center {
  text-align: center;
}

.center h1 {
  margin-bottom: 10px;
}
```

<sup>7</sup>**图5.6: 添加空格和通用样式的结果**

列表5.7的CSS格式是一致的。CSS规则通常指定类、id、HTML标签或它们的组合之一。然后在其后面描述样式命令列表。例如,以下代码

```css
body {
  padding-top: 60px;
}
```

在页面顶部添加60像素的空白。由于header标签被赋予了`navbar-fixed-top`类,Bootstrap据此将导航栏固定在页面顶部,并在导航栏下方放置空白以与主要部分分离。`navbar-inverse`类将默认navbar的颜色更改为深色调。此外,此规则中的以下CSS

```css
.center {
  text-align: center;
}
```

将`text-align: center`属性与center类关联起来。换句话说,`.center`开头的点`.`表示此规则将样式应用于类。另外,如列表5.9所示,如果开头是井号`#`,则表示该规则将样式应用于CSS的id。在这种情况下,这意味着属于center类的div等标签内部的所有元素都将居中对齐(列表5.2是实际使用示例)。

Bootstrap有可以使用精致排版的CSS规则,但这里我们还将添加列表5.8所示的自定义CSS规则,改变文本的外观。另外,这次添加的规则并不都适用于Home页面,但会在示例应用程序的其他地方使用。可以在图5.7中确认反映列表5.8的结果。

**列表5.8: 添加CSS以使用精致的排版**  
`app/assets/stylesheets/custom.scss`

```scss
@import "bootstrap-sprockets";
@import "bootstrap";
...

/* typography */

h1, h2, h3, h4, h5, h6 {
  line-height: 1;
}

h1 {
  font-size: 3em;
  letter-spacing: -2px;
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 1.2em;
  letter-spacing: -1px;
  margin-bottom: 30px;
  text-align: center;
  font-weight: normal;
  color: #777;
}

p {
  font-size: 1.1em;
  line-height: 1.7em;
}
```

<sup>7</sup>**图5.7: 添加排版样式**

最后,向网站logo添加一些规则。这个网站logo是只显示"sample app"的简单logo。列表5.9的CSS将文本转换为大写,并更改大小、颜色和位置(使用CSS id的前提是网站logo在页面中只使用一次,但也可以使用类)。

**列表5.9: 向网站logo添加CSS**  
`app/assets/stylesheets/custom.scss`

```scss
@import "bootstrap-sprockets";
@import "bootstrap";
...

/* header */

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
}

#logo:hover {
  color: #fff;
  text-decoration: none;
}
```

上面代码中的`color: #fff`将logo的颜色更改为白色。HTML颜色用十六进制(基数为16)的三个数字组合表示,从左到右可以编码为红、绿、蓝三原色。本来应该写成`#ffffff`使三种颜色都最大化,但上面的代码使用了`#ffffff`的缩写形式`#fff`。顺便说一下,CSS标准还为HTML颜色定义了许多别名。例如,刚才的`#fff`也可以写成white。

回到正题,如果反映了列表5.9的CSS,成功的话应该如图5.8所示。

<sup>7</sup>**图5.8: 设计的logo和示例应用**

#### 练习

参考列表5.10,尝试注释掉5.1.1.1练习中使用的猫图片。另外,使用浏览器的HTML检查器功能,确认注释掉后HTML源代码中也消失了。

将列表5.11的代码添加到`custom.scss`,尝试隐藏所有图像。如果顺利,Rails logo图像应该从Home页面消失。与之前一样使用检查器功能,这次确认HTML源代码保留但只有图像不显示。此练习完成后,必须撤销所做的更改(否则之后的图像将无法正确显示)。

**列表5.10: 注释掉ERB代码**

```erb
<%#= image_tag("kitten.jpg", alt: "Kitten") %>
```

**列表5.11: 隐藏所有图像的CSS**

```css
img {
  display: none;
}
```

### 5.1.3 局部视图(partial)

**用解说视频学习吧**  
**观看**

布局代码(列表5.1)虽然实现了其目的,但还有点凌乱。例如,HTML头部作为一个逻辑单元可以分离,集中在一个地方会更方便。在Rails中,可以使用称为局部视图(partial)的功能来解决这类问题。首先,让我们看看定义局部视图后布局如何变化(列表5.12)。

**列表5.12: 在布局中添加header的局部视图**  
`app/views/layouts/application.html.erb`

```erb
<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <%= yield %>
    </div>
  </body>
</html>
```

在列表5.12中,使用了称为render的Rails辅助方法调用来替换header信息。

```erb
<%= render 'layouts/header' %>
```

这一行查找名为`app/views/layouts/_header.html.erb`的文件,评估其内容,并将结果插入视图<sup>14</sup>。`<%= ... %>`是在模板中评估Ruby表达式的ERB记法。评估的结果被插入到模板中。请注意文件名`_header.html.erb`开头的下划线。这个下划线是局部视图使用的通用命名约定,也使得可以一眼识别目录中的所有局部视图。

为了使局部视图工作,必须描述相应的文件和内容。创建的代码如列表5.13所示。局部视图通常不自动生成,而是使用编辑器手动创建。

**列表5.13: header的局部视图**  
`app/views/layouts/_header.html.erb`

```erb
<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "sample app", '#', id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home",   '#' %></li>
        <li><%= link_to "Help",   '#' %></li>
        <li><%= link_to "Log in", '#' %></li>
      </ul>
    </nav>
  </div>
</header>
```

现在知道了如何创建局部视图,让我们用同样的方法添加页脚。到这里你应该明白,文件名是`_footer.html.erb`,应该放在layouts目录中(列表5.14)<sup>15</sup>。

**列表5.14: 网站footer的局部视图**  
`app/views/layouts/_footer.html.erb`

```erb
<footer class="footer">
  <small>
    The <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
    by <a href="https://www.michaelhartl.com/">Michael Hartl</a>
  </small>
  <nav>
    <ul>
      <li><%= link_to "About",   '#' %></li>
      <li><%= link_to "Contact", '#' %></li>
      <li><a href="https://news.railstutorial.org/">News</a></li>
    </ul>
  </nav>
</footer>
```

与header一样,在footer中也使用了`link_to`方法添加到About页面和Contact页面的内部链接。暂时将链接URL设为'#'(与header标签一样,footer标签也是HTML5新增的元素)。

可以使用与样式表和header局部视图相同的方法在布局中添加footer局部视图(列表5.15)。

**列表5.15: 在布局中添加footer局部视图**  
`app/views/layouts/application.html.erb`

```erb
<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <%= yield %>
      <%= render 'layouts/footer' %>
    </div>
  </body>
</html>
```

接下来让我们为footer添加一些样式(列表5.16)。添加样式的结果如图5.9所示。

**列表5.16: 向网站添加footer的CSS**  
`app/assets/stylesheets/custom.scss`

```scss
...
/* footer */

footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid #eaeaea;
  color: #777;
}

footer a {
  color: #555;
}

footer a:hover {
  color: #222;
}

footer small {
  float: left;
}

footer ul {
  float: right;
  list-style: none;
}

footer ul li {
  float: left;
  margin-left: 15px;
}
```

<sup>7</sup>**图5.9: 向Home页面添加footer**

#### 练习

如果还没有开始5.4.1.1的练习,请先像列表5.17那样修改,使其可以使用命名路由`signup_path`。另外,由于在列表5.42中可以使用命名路由,现在应该确认测试是green的。

为了确认刚才的测试正确工作,请注释掉signup路由部分,确认测试变为red。确认后,取消注释恢复到green状态。

在列表5.31的集成测试中添加访问signup页面的代码(使用get方法)。添加代码后实际运行测试,确认结果正确。(提示:使用列表5.35中介绍的`full_title`辅助方法。)

**列表5.17: 将Rails默认的head标签替换为render**  
`app/views/layouts/application.html.erb`

```erb
<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <%= render 'layouts/rails_default' %>
  </head>
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <%= yield %>
      <%= render 'layouts/footer' %>
    </div>
  </body>
</html>
```

## 5.2 Sass和Asset Pipeline

Rails最近添加的功能中最值得一提的之一是"Asset Pipeline",它大大增强了创建和管理CSS、图像等静态内容的能力。在本节中,我们将说明Asset Pipeline的概述以及强大的CSS生成工具"Sass"的使用方法。

### 5.2.1 Asset Pipeline

从Rails开发者的角度来看,需要理解三个主要功能:资源目录、清单文件和预处理器引擎<sup>16</sup>。让我们依次看看每一个。

#### 资源目录

Rails的Asset Pipeline使用三个标准目录来分类静态文件:

- **app/assets**: 当前应用程序特有的资源
- **lib/assets**: 由你的开发团队创建的库的资源
- **vendor/assets**: 第三方资源(默认不存在)

这些目录有两个资源类的子目录。例如,对于`app/assets`,有以下用于图像和CSS的子目录:

```bash
$ ls app/assets/
config  images  stylesheets
```

到现在为止,大家应该已经理解了5.1.2中提到的自定义CSS放置的位置及其原因。因为`custom.scss`是示例应用程序特有的资源,所以放在`app/assets/stylesheets`是合适的。

#### 清单文件

将静态文件(资源)分别放置在上述位置后,可以使用清单文件指示Rails如何将它们组合成一个文件。实际上,执行资源组合处理的是名为Sprockets的gem。另外,清单文件适用于CSS和JavaScript,但不适用于图像文件。

作为一个具体示例,让我们看看应用程序的CSS清单文件(列表5.18)。

**列表5.18: 应用程序特有的CSS清单文件**  
`app/assets/stylesheets/application.css`

```css
/*
 * This is a manifest file that'll be compiled into application.css, which
 * will include all the files
 * listed below.
 *
 * Any CSS (and SCSS, if configured) file within this directory,
 * lib/assets/stylesheets, or any plugin's
 * vendor/assets/stylesheets directory can be referenced here using
 * a relative path.
 *
 * You're free to add application-wide styles to this file and they'll
 * appear at the bottom of the
 * compiled file so the styles you add here take precedence over styles
 * defined in any other CSS
 * files in this directory. Styles in this file should be added after the
 * last require_* statement.
 * It is generally better to create a new file per style scope.
 *
 *= require_tree .
 *= require_self
 */
```

上面行中重要的部分实际上在CSS注释中。注释中的以下部分被Sprockets用来加载适当的文件。

```
/*
 . . .
 *= require_tree .
 *= require_self
*/
```

例如,以下行指示将`app/assets/stylesheets`目录(包括子目录)中的所有CSS文件包含在应用程序CSS中。

```
 *= require_tree .
```

另外,以下行指示在CSS加载序列中也包含`application.css`本身。

```
 *= require_self
```

Rails附带实用的默认清单文件,所以在Rails教程中不需要进行更改,但如果需要,可以在Rails指南的"Asset Pipeline"中参考详细信息。

#### 预处理器引擎

Rails在将必要的资源放置在目录中并组合后,通过运行各种预处理器引擎进行组合,使其可以传递给浏览器。在Rails中,通过文件名的扩展名判断对哪个文件使用哪个预处理器。在大多数情况下,如果文件名末尾的扩展名是`.erb`,则执行ERB预处理(前处理),如果是`.scss`,则执行Sass预处理。ERB在3.4.3中已经说明。Sass将在5.2.2中稍后描述。

#### 生产环境的效率

Asset Pipeline的最大优势之一是可以自动生成针对生产应用程序优化的资源。传统上,为了组织CSS,经常将功能分割到不同的文件中,并使用大量缩进格式化为易读的格式。这对程序员来说是一种方便的方法,但对生产环境来说是低效的。原因是将未最小化的CSS文件分割成多个CSS文件会显著延长页面加载时间。加载时间长会降低用户体验质量,因此加载时间是重要指标之一。

使用Asset Pipeline,就不需要为"开发效率和加载时间哪个更重要"这个问题而烦恼。在开发环境中,以程序员易读的格式组织,在生产环境中用Asset Pipeline最小化文件即可。具体来说,Asset Pipeline将所有样式表组合成一个CSS文件`application.css`。此外,对所有这些文件执行删除不必要空格和缩进的处理,最小化文件大小。这样就为开发环境和生产环境都提供了最佳环境。

在生产环境中编译资源的方法因环境而异,但在Render中默认设置了命令。从仪表板打开sample_app的WEB SERVICE,打开Settings选项卡并确认Build Command(图5.10)。

<sup>7</sup>**图5.10: 编译文件的命令**

### 5.2.2 具有出色语法的样式表

Sass的基础知识可以在Progate的"Sass"课程中学习。

Sass是一种用于编写样式表的语言,在许多方面都增强了CSS。在本节中,我们将说明Sass提供的两个重要功能:嵌套和变量。(第三个重要功能mixin将在7.2.1中介绍。)

如5.1.2中简要说明的,Sass对应SCSS格式(`.scss`扩展名表示SCSS)。SCSS在严格意义上是CSS本体的抽象格式。也就是说,SCSS只是向CSS添加了新功能,而不是定义了全新的语法<sup>17</sup>。因此,所有有效的CSS文件也可以作为SCSS文件处理,对于使用现有记法规则的项目来说是一种兼容且方便的格式。在本书的示例中,为了获得Bootstrap的好处,我们从一开始就使用SCSS。Rails的Asset Pipeline会自动使用Sass处理扩展名为`.scss`的文件。因此,`custom.scss`文件经过Sass预处理器前处理,然后打包以准备传递给浏览器。

#### 嵌套

如果样式表中存在通用模式,可以嵌套元素。例如,在列表5.7中,`.center`和`.center h1`都有规则。

```css
.center {
  text-align: center;
}

.center h1 {
  margin-bottom: 10px;
}
```

上述规则可以使用Sass重写如下。

```scss
.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }
}
```

在上面的示例中,嵌套内部的h1规则继承了`.center`的规则。

现在让我们看一个对稍微不同的规则使用嵌套功能的示例。列表5.9有以下代码。

```css
#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
}

#logo:hover {
  color: #fff;
  text-decoration: none;
}
```

上述代码中`#logo` id被使用了两次。第一次用于定义logo本身,第二次用于定义hover属性(hover属性定义将鼠标指针悬停在相应元素上时的显示)。为了嵌套第二个规则,需要引用父属性`#logo`。在这种情况下,SCSS可以使用&符号来实现。

```scss
#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
  &:hover {
    color: #fff;
    text-decoration: none;
  }
}
```

Sass在将SCSS转换为CSS时,将`&:hover`替换为`#logo:hover`。

这些嵌套功能也可以在footer的CSS中使用。列表5.16的代码可以使用SCSS重写如下。

```scss
footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid #eaeaea;
  color: #777;
  a {
    color: #555;
    &:hover {
      color: #222;
    }
  }
  small {
    float: left;
  }
  ul {
    float: right;
    list-style: none;
    li {
      float: left;
      margin-left: 15px;
    }
  }
}
```

手动转换列表5.16是一个很好的练习。(实际上在5.2.2.3的练习中也采用了这种方法)。转换后,请确认CSS仍然正常工作。

#### 变量

在Sass中,可以定义变量以消除冗余代码并实现更自由的表达。例如,看看列表5.8和列表5.16,有重复引用相同颜色的地方。

```scss
h2 {
  .
  .
  .
  color: #777;
}
...
footer {
  .
  .
  .
  color: #777;
}
```

上述代码中的`#777`表示浅灰色。在Sass中,可以将这样的值定义为变量,并赋予变量名,如下所示。

```scss
$light-gray: #777;
```

使用此功能,可以将SCSS重写如下。

```scss
$light-gray: #777;
...
h2 {
  .
  .
  .
  color: $light-gray;
}
...
footer {
  .
  .
  .
  color: $light-gray;
}
```

像`$light-gray`这样的变量名比`#777`这样的原始值更容易理解含义,因此即使该变量不重复使用,赋予变量名在许多情况下也是有用的。实际上,Bootstrap框架为许多颜色定义了变量名。可以在Bootstrap页面的"LESS变量列表"中参考定义的变量。此网站使用LESS而不是Sass定义变量,但使用`bootstrap-sass` gem可以在Sass中使用类似的变量。LESS使用@符号,而Sass使用$符号,所以很容易区分。例如,查看Bootstrap的变量列表,可以发现为浅灰色赋予了以下变量名:

```
@gray-light: #777;
```

这意味着使用`bootstrap-sass` gem,在SCSS中也可以使用`$gray-light`变量。让我们使用准备好的变量代替之前定义的`$light-gray`自定义变量。

```scss
h2 {
  .
  .
  .
  color: $gray-light;
}
...
footer {
  .
  .
  .
  color: $gray-light;
}
```

使用本次介绍的Sass嵌套功能和变量功能全面重写SCSS文件,结果如列表5.19所示。此列表使用Sass变量(详细信息请参考Bootstrap LESS变量列表)和内置颜色变量(例如`#fff`有white变量)。请确认footer标签的规则得到了显著改进。

**列表5.19: 使用嵌套和变量重写初始SCSS文件的结果**  
`app/assets/stylesheets/custom.scss`

```scss
@import "bootstrap-sprockets";
@import "bootstrap";

/* mixins, variables, etc. */

$gray-medium-light: #eaeaea;

/* universal */

body {
  padding-top: 60px;
}

section {
  overflow: auto;
}

textarea {
  resize: vertical;
}

.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }
}

/* typography */

h1, h2, h3, h4, h5, h6 {
  line-height: 1;
}

h1 {
  font-size: 3em;
  letter-spacing: -2px;
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 1.2em;
  letter-spacing: -1px;
  margin-bottom: 30px;
  text-align: center;
  font-weight: normal;
  color: $gray-light;
}

p {
  font-size: 1.1em;
  line-height: 1.7em;
}

/* header */

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: white;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
  &:hover {
    color: white;
    text-decoration: none;
  }
}

/* footer */

footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid $gray-medium-light;
  color: $gray-light;
  a {
    color: $gray;
    &:hover {
      color: $gray-darker;
    }
  }
  small {
    float: left;
  }
  ul {
    float: right;
    list-style: none;
    li {
      float: left;
      margin-left: 15px;
    }
  }
}
```

虽然还有其他使用Sass简化样式表的方法,但这次我们使用了其中最重要的功能重写为列表5.19。使用Sass可以有一个出色的开始。有关Sass的详细信息,请参考Sass官方网站(英语)。

#### 练习

如5.2.2中建议的那样,尝试手动转换footer的CSS。具体来说,逐个转换列表5.16的内容,使其像列表5.19那样。

## 5.3 布局的链接

**用解说视频学习吧**  
**观看**

网站布局已经美观地完成了,现在让我们重写用'#'代替的链接。Rails的ERB模板允许直接编写纯HTML,因此也可以直接描述如下链接。

```html
<a href="/static_pages/about">About</a>
```

但是,上述记法不是Rails风格。首先,about页面的URL最好是`/about`而不是`/static_pages/about`。此外,在Rails中,按照惯例使用如下代码的命名路由。

```erb
<%= link_to "About", about_path %>
```

这样做可以使代码含义更清晰,而且通过更改`about_path`的定义可以更改使用`about_path`的所有URL,从而提高灵活性。

表5.1显示了将要使用的URL和路由(route)之间的映射。虽然在3.4.4中已经设置了第一个路由,但我们将以类似的方式实现其他路由。另外,关于login,我们将在本章最后稍微实现一下(第8章将正式实现)。

| 页面名称 | URL | 命名路由 |
|---------|-----|---------|
| Home | / | root_path |
| About | /about | about_path |
| Help | /help | help_path |
| Contact | /contact | contact_path |
| Sign up | /signup | signup_path |
| Log in | /login | login_path |

**表5.1: 网站链接的路由和URL映射**

### 5.3.1 Contact页面

首先,让我们添加第3章练习中提到的Contact页面。Contact页面的测试如列表5.20所示。这只是遵循列表3.25中使用的测试模式。

**列表5.20: Contact页面的测试** <span style="color:red">red</span>  
`test/controllers/static_pages_controller_test.rb`

```ruby
require "test_helper"

class StaticPagesControllerTest < ActionDispatch::IntegrationTest

  test "should get home" do
    get static_pages_home_url
    assert_response :success
    assert_select "title", "Ruby on Rails Tutorial Sample App"
  end

  test "should get help" do
    get static_pages_help_url
    assert_response :success
    assert_select "title", "Help | Ruby on Rails Tutorial Sample App"
  end

  test "should get about" do
    get static_pages_about_url
    assert_response :success
    assert_select "title", "About | Ruby on Rails Tutorial Sample App"
  end

  test "should get contact" do
    get static_pages_contact_url
    assert_response :success
    assert_select "title", "Contact | Ruby on Rails Tutorial Sample App"
  end
end
```

此时,列表5.20的测试应该是<span style="color:red">red</span>。

**列表5.21:** <span style="color:red">red</span>

```bash
$ rails test
```

应用程序代码与3.3中添加到About页面非常相似。首先更新路由(列表5.22)。接下来在StaticPages控制器中添加contact动作(列表5.23)。最后创建Contact视图(列表5.24)。

**列表5.22: 添加Contact页面的路由** <span style="color:red">red</span>  
`config/routes.rb`

```ruby
Rails.application.routes.draw do
  root "static_pages#home"
  get  "static_pages/home"
  get  "static_pages/help"
  get  "static_pages/about"
  get  "static_pages/contact"
end
```

**列表5.23: 为Contact页面添加动作** <span style="color:red">red</span>  
`app/controllers/static_pages_controller.rb`

```ruby
class StaticPagesController < ApplicationController
  .
  .
  .
  def contact
  end
end
```

**列表5.24: 添加Contact页面的视图** <span style="color:green">green</span>  
`app/views/static_pages/contact.html.erb`

```erb
<% provide(:title, 'Contact') %>
<h1>Contact</h1>
<p>
  Contact the Ruby on Rails Tutorial about the sample app at the
  <a href="https://railstutorial.jp/contact">contact page</a>.
</p>
```

在这里,请确认所有测试都是<span style="color:green">green</span>。

**列表5.25:** <span style="color:green">green</span>

```bash
$ rails test
```

### 5.3.2 Rails的路由URL

在本节中,为了在示例应用程序的静态页面中使用命名路由,我们将编辑路由文件(`config/routes.rb`)。首先,让我们回顾一下在3.4.4中定义的Home页面的路由。那时我们只特别设置了Home页面,但我们将对其余静态页面进行类似的路由设置。

到目前为止,我们已经看到了三次定义根URL的代码。第一个是Hello应用程序的代码`root "application#hello"`(列表1.11)。第二个是Toy应用程序的代码`root "users#index"`(列表2.4)。最后是Sample应用程序的代码`root "static_pages#home"`(列表3.42)。在任何情况下,都使用root方法将根URL "/"绑定到控制器的动作。

定义根URL等路由的效果不仅是使浏览器更容易访问。除此之外,还可以使用命名路由而不是原始URL来引用URL。例如,定义根URL后,可以通过`root_path`和`root_url`等方法引用URL。顺便说一下,前者返回根URL以下的字符串,后者返回完整URL的字符串。

```
root_path -> '/'
root_url  -> 'https://www.example.com/'
```

另外,在Rails教程中,我们遵循一般惯例,基本上使用`_path`格式,仅在重定向时使用`_url`格式。这是因为HTTP标准要求在重定向时使用完整URL。但是,在大多数浏览器中,两种方法都可以工作。

列表5.20中使用的默认路由有些冗长,所以让我们定义Help页面、About页面、Contact页面等的命名路由。具体来说,使用get规则定义(列表5.22)。例如,以下路由

```ruby
get "static_pages/help"
```

这样转换。

```ruby
get  "/help", to: "static_pages#help"
```

使用get规则这样更改后,当GET请求发送到`/help`时,就会调用StaticPages控制器的help动作。另外,与根URL一样,也可以使用`help_path`和`help_url`等命名路由。

```
help_path -> '/help'
help_url  -> 'https://www.example.com/help'
```

对其他静态页面进行类似的路由更改,列表5.22变成列表5.26所示的代码。

**列表5.26: 静态页面的路由列表** <span style="color:red">red</span>  
`config/routes.rb`

```ruby
Rails.application.routes.draw do
  root "static_pages#home"
  get  "/help",    to: "static_pages#help"
  get  "/about",   to: "static_pages#about"
  get  "/contact", to: "static_pages#contact"
end
```

另外,请注意列表5.26删除了以前的`'static_pages/home'`规则。从现在开始,我们将始终使用`root_path`或`root_url`。

此外,列表5.20的测试也已过时,因此需要更改。实际上,现在的测试应该是<span style="color:red">red</span>。要再次恢复到<span style="color:green">green</span>状态,需要像列表5.27那样修改。此时,请注意由于路由更改现在可以使用命名路由(`*_path`),所以在测试修改中已经使用了它。

**列表5.27: 对StaticPages中新命名路由的测试** <span style="color:green">green</span>  
`test/controllers/static_pages_controller_test.rb`

```ruby
require "test_helper"

class StaticPagesControllerTest < ActionDispatch::IntegrationTest

  test "should get home" do
    get root_path
    assert_response :success
    assert_select "title", "Ruby on Rails Tutorial Sample App"
  end

  test "should get help" do
    get help_path
    assert_response :success
    assert_select "title", "Help | Ruby on Rails Tutorial Sample App"
  end

  test "should get about" do
    get about_path
    assert_response :success
    assert_select "title", "About | Ruby on Rails Tutorial Sample App"
  end

  test "should get contact" do
    get contact_path
    assert_response :success
    assert_select "title", "Contact | Ruby on Rails Tutorial Sample App"
  end
end
```

#### 练习

实际上,命名路由可以使用`as:`选项更改。根据著名的Far Side漫画,尝试将Help页面的命名路由更改为helf(列表5.28)。由于刚才的更改,请确认测试变为<span style="color:red">red</span>。参考列表5.27更新路由,使测试变为<span style="color:green">green</span>。使用编辑器的Undo功能撤销此练习所做的更改。

**列表5.28: 将help更改为helf**  
`config/routes.rb`

```ruby
Rails.application.routes.draw do
  root "static_pages#home"
  get  "/help",    to: "static_pages#help", as: 'helf'
  get  "/about",   to: "static_pages#about"
  get  "/contact", to: "static_pages#contact"
end
```

### 5.3.3 命名路由

通过在列表5.26中定义路由,现在可以在布局中使用命名路由了。让我们立即在`link_to`方法的第二个参数中使用适当的命名路由。例如,对于以下代码

```erb
<%= link_to "About", '#' %>
```

这样替换。

```erb
<%= link_to "About", about_path %>
```

其他也是一样。首先从有Home页面和Help页面链接的header局部视图`_header.html.erb`(列表5.29)开始。在header局部视图中,遵循Web通用惯例,也为logo添加到Home页面的链接。

**列表5.29: 向header局部视图添加链接**  
`app/views/layouts/_header.html.erb`

```erb
<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "sample app", root_path, id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home",    root_path %></li>
        <li><%= link_to "Help",    help_path %></li>
        <li><%= link_to "Log in", '#' %></li>
      </ul>
    </nav>
  </div>
</header>
```

[Log in]链接的命名路由将在第8章创建,所以现在暂时保持为'#'。

footer局部视图`_footer.html.erb`也有链接。这些是到About页面和Contact页面的链接(列表5.30)。

**列表5.30: 向footer局部视图添加链接**  
`app/views/layouts/_footer.html.erb`

```erb
<footer class="footer">
  <small>
    The <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
    by <a href="https://www.michaelhartl.com/">Michael Hartl</a>
  </small>
  <nav>
    <ul>
      <li><%= link_to "About",   about_path %></li>
      <li><%= link_to "Contact", contact_path %></li>
      <li><a href="https://news.railstutorial.org/">News</a></li>
    </ul>
  </nav>
</footer>
```

这样,布局中就有了到第3章创建的所有静态页面的链接。例如,对于`/about`,会移动到About页面(图5.11)。

<sup>7</sup>**图5.11: 在/about显示的About页面**

#### 练习

像列表5.28那样创建helf路由,并尝试更新布局中的链接。与上次练习一样,使用编辑器的Undo功能撤销此练习所做的更改。

### 5.3.4 链接测试

由于已经填充了布局中的一些链接,让我们编写测试来检查这些链接是否正常工作。可以启动浏览器访问根URL,然后单击每个链接进行确认,但每次更改都重复这项工作是很大的负担。因此,让我们使用"集成测试(Integration Test)"来自动化这一系列工作。使用集成测试可以从头到尾(end-to-end)模拟和测试应用程序的行为。

首先,从生成名为site_layout的测试模板开始。

```bash
$ rails generate integration_test site_layout
      invoke  test_unit
      create    test/integration/site_layout_test.rb
```

此时,请注意Rails在传递的文件名末尾添加了`_test`字符串。这次的目的是检查应用程序的HTML结构,看看布局中的每个链接是否正常工作。也就是说:

1. 向根URL(Home页面)发送GET请求。
2. 确认是否渲染了正确的页面模板。
3. 确认Home、Help、About、Contact各页面的链接是否正常工作。

在Rails的集成测试中,将上述步骤转化为代码(列表5.31)。具体来说,首先使用`assert_template`方法确认Home页面是否渲染了正确的视图<sup>18</sup>。

**列表5.31: 布局链接的测试** <span style="color:green">green</span>  
`test/integration/site_layout_test.rb`

```ruby
require "test_helper"

class SiteLayoutTest < ActionDispatch::IntegrationTest

  test "layout links" do
    get root_path
    assert_template 'static_pages/home'
    assert_select "a[href=?]", root_path, count: 2
    assert_select "a[href=?]", help_path
    assert_select "a[href=?]", about_path
    assert_select "a[href=?]", contact_path
  end
end
```

在列表5.31中,使用了`assert_select`方法的高级选项。这个方法本身在列表3.25和列表5.20中也出现了。在这种情况下,通过指定特定链接是否存在,使用a标签和href属性作为选项进行检查。例如,

```ruby
assert_select "a[href=?]", about_path
```

在上述代码中,Rails自动将问号"?"替换为`about_path`。此时,如果"about_path"中有特殊字符,会进行转义处理。这样可以检查是否有以下HTML。

```html
<a href="/about">...</a>
```

另一方面,请记住根URL的链接有两个(一个在logo上,另一个在导航栏中)。这种时候,

```ruby
assert_select "a[href=?]", root_path, count: 2
```

像这样编写,也可以检查列表5.29中定义的Home页面链接的数量。

`assert_select`有各种指定方式。表5.2介绍了一些代表性示例。`assert_select`是灵活而强大的功能,这里无法介绍所有其他选项。但根据经验,最好不要用此方法进行复杂的测试。最好将测试限制在布局中经常更改的链接等HTML元素上。

| Code | 匹配的HTML |
|------|----------|
| `assert_select "div"` | `<div>foobar</div>` |
| `assert_select "div", "foobar"` | `<div>foobar</div>` |
| `assert_select "div.nav"` | `<div class="nav">foobar</div>` |
| `assert_select "div#profile"` | `<div id="profile">foobar</div>` |
| `assert_select "div[name=yo]"` | `<div name="yo">hey</div>` |
| `assert_select "a[href=?]", '/', count: 1` | `<a href="/">foo</a>` |
| `assert_select "a[href=?]", '/', text: "foo"` | `<a href="/">foo</a>` |

**表5.2: assert_select的一些使用示例**

可以通过运行以下Rails命令来测试列表5.31中添加的集成测试是否通过。

**列表5.32:** <span style="color:green">green</span>

```bash
$ rails test:integration
```

集成测试成功后,现在运行所有测试,看看是否<span style="color:green">green</span>。

**列表5.33:** <span style="color:green">green</span>

```bash
$ rails test
```

由于添加了测试布局链接的集成测试,现在可以立即注意到对链接的错误更改。

#### 练习

将footer局部视图中的`about_path`更改为`contact_path`,确认测试是否正确捕获了错误。

如列表5.34所示,在test环境中也可以使用Application辅助方法中使用的`full_title`辅助方法会很方便。这样,就可以使用列表5.35所示的代码测试正确的标题。但是,这不是完美的测试。例如,如果基础标题有"Ruby on Rails Tutoial"等拼写错误,此测试也无法发现。为了解决这个问题,需要为`full_title`辅助方法编写测试。因此,创建一个测试Application辅助方法的文件,将列表5.36中(写入代码)的部分替换为适当的代码。(提示:在列表5.36中,使用`assert_equal <期望值>, <实际值>`的形式,内部使用==运算符比较期望值和实际值,测试是否正确。)

**列表5.34: 使test环境也能使用Application辅助方法**  
`test/test_helper.rb`

```ruby
ENV['RAILS_ENV'] ||= 'test'
...
class ActiveSupport::TestCase
  # 以指定的worker数并行运行测试
  parallelize(workers: :number_of_processors)
  # 设置test/fixtures/*.yml的所有fixture
  fixtures :all
  include ApplicationHelper
  .
  .
  .
end
```

**列表5.35: 在test环境中使用full_title辅助方法** <span style="color:green">green</span>  
`test/integration/site_layout_test.rb`

```ruby
require "test_helper"

class SiteLayoutTest < ActionDispatch::IntegrationTest

  test "layout links" do
    get root_path
    assert_template 'static_pages/home'
    assert_select "a[href=?]", root_path, count: 2
    assert_select "a[href=?]", help_path
    assert_select "a[href=?]", about_path
    assert_select "a[href=?]", contact_path
    get contact_path
    assert_select "title", full_title("Contact")
  end
end
```

**列表5.36: full_title辅助方法的单元测试**  
`test/helpers/application_helper_test.rb`

```ruby
require "test_helper"

class ApplicationHelperTest < ActionView::TestCase
  test "full title helper" do
    assert_equal (写入代码), full_title
    assert_equal (写入代码), full_title("Help")
  end
end
```

## 5.4 用户注册:最初的步骤

在本节中,作为布局和路由工作的顶点,我们将创建用户注册页面的路由。为此,我们将创建第二个控制器。这将是在网站上实现用户注册的重要第一步。下一步——用户建模将在第6章进行,用户注册将在第7章完成。

### 5.4.1 Users控制器

在3.2中,我们创建了第一个控制器StaticPages控制器。现在让我们创建第二个控制器Users控制器。与之前一样,执行generate创建最简单的控制器,该控制器具有当前需求的新用户注册页面(存根)。遵循Rails首选的REST架构约定,将新用户的动作命名为new。在generate controller的参数中传递new就会自动创建此动作。更改的结果如列表5.37所示。

**列表5.37: 生成Users控制器(添加new动作)**

```bash
$ rails generate controller Users new
      create  app/controllers/users_controller.rb
       route  get "users/new"
      invoke  erb
      create    app/views/users
      create    app/views/users/new.html.erb
      invoke  test_unit
      create    test/controllers/users_controller_test.rb
      invoke  helper
      create    app/helpers/users_helper.rb
      invoke    test_unit
```

列表5.37创建了具有new动作的Users控制器(列表5.38)和用户视图的存根(列表5.39)。此时,还生成了新User页面的小测试(列表5.40),此时应该通过。

**列表5.38: 具有new动作的最初Users控制器**  
`app/controllers/users_controller.rb`

```ruby
class UsersController < ApplicationController
  def new
  end
end
```

**列表5.39: Users的最初new动作**  
`app/views/users/new.html.erb`

```erb
<h1>Users#new</h1>
<p>Find me in app/views/users/new.html.erb</p>
```

**列表5.40: User页面的最初测试** <span style="color:green">green</span>  
`test/controllers/users_controller_test.rb`

```ruby
require "test_helper"

class UsersControllerTest < ActionDispatch::IntegrationTest
  test "should get new" do
    get users_new_url
    assert_response :success
  end
end
```

此时,测试应该是<span style="color:green">green</span>。

**列表5.41:** <span style="color:green">green</span>

```bash
$ rails test
```

#### 练习

参考表5.1,修改列表5.40,使其可以使用`signup_path`而不是`users_new_url`。由于刚才的更改,请确认测试变为<span style="color:red">red</span>。另外,此练习旨在创建测试驱动开发(专栏3.3)中说明的red / green节奏。此测试将在下一节5.4.2中修改为<span style="color:green">green</span>。

### 5.4.2 用户注册URL

通过5.4.1的代码,在`/users/new`创建了新用户的工作页面。在这里我想回顾一下表5.1,URL不是`/users/new`而是希望按表中那样设为`/signup`。遵循列表5.26的示例,为用户注册URL添加`get "/signup"`路由(列表5.42)。

**列表5.42: 用户注册页面的路由** <span style="color:red">red</span>  
`config/routes.rb`

```ruby
Rails.application.routes.draw do
  root "static_pages#home"
  get  "/help",    to: "static_pages#help"
  get  "/about",   to: "static_pages#about"
  get  "/contact", to: "static_pages#contact"
  get  "/signup",  to: "users#new"
end
```

配合列表5.42的更改,也修改列表5.37生成的测试。修改后的结果如列表5.43所示。

**列表5.43: 在Users控制器的测试中使用命名路由** <span style="color:green">green</span>  
`test/controllers/users_controller_test.rb`

```ruby
require "test_helper"

class UsersControllerTest < ActionDispatch::IntegrationTest
  test "should get new" do
    get signup_path
    assert_response :success
  end
end
```

接下来,使用新定义的命名路由向Home页面的按钮添加适当的链接。与其他路由一样,通过编写`get "/signup"`,创建了名为`signup_path`的命名路由,在列表5.44中使用它。另外,signup页面的测试将在练习(5.4.2.1)中进行。

**列表5.44: 向按钮添加用户注册页面的链接**  
`app/views/static_pages/home.html.erb`

```erb
<div class="center jumbotron">
  <h1>Welcome to the Sample App</h1>
  <h2>
    This is the home page for the
    <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
    sample application.
  </h2>
  <%= link_to "Sign up now!", signup_path, class: "btn btn-lg btn-primary" %>
</div>

<%= link_to image_tag("rails.svg", alt: "Rails logo", width: "200"),
                      "https://rubyonrails.org/" %>
```

最后,为signup页面添加自定义存根(stub)视图(列表5.45)。

**列表5.45: 最初的用户注册页面(存根)**  
`app/views/users/new.html.erb`

```erb
<% provide(:title, 'Sign up') %>
<h1>Sign up</h1>
<p>This will be a signup page for new users.</p>
```

这样,至少在添加登录路由之前(第8章),链接和命名路由就完成了。结果如图5.12所示,URI为`/signup`的新用户页面。

<sup>7</sup>**图5.12: 新的用户注册页面(/signup)**

#### 练习

如果还没有开始5.4.1.1的练习,请先像列表5.40那样更改,使其可以使用命名路由`signup_path`。另外,由于在列表5.42中可以使用命名路由,现在应该确认测试是<span style="color:green">green</span>的。

为了确认刚才的测试正确工作,请注释掉signup路由部分,确认测试变为<span style="color:red">red</span>。确认后,取消注释恢复到<span style="color:green">green</span>状态。

在列表5.31的集成测试中添加访问signup页面的代码(使用get方法)。添加代码后实际运行测试,确认结果正确。(提示:使用列表5.35中介绍的`full_title`辅助方法。)

## 5.5 最后

**如果遇到困难,请边看解说视频边一起做**  
**观看**

在本章中,我们完成了应用程序的布局,并完善了路由。从现在开始,本书将专注于充实示例应用程序。首先,添加可以注册、登录和退出的用户。接下来,添加微博。最后,使其可以关注其他用户。

如果使用Git,请在此时将更改合并到main分支。

```bash
$ git add -A
$ git commit -m "Finish layout and routes"
$ git switch main
$ git merge filling-in-layout
```

然后,运行测试套件确认是否<span style="color:green">green</span>,如果没问题就推送到GitHub并部署。

```bash
$ rails test
$ git push
```

部署成功后,示例应用程序应该在生产环境中运行(图5.13)。

<sup>7</sup>**图5.13: 在生产环境中运行的示例应用程序**

如果发生故障,请参考Render仪表板的"Logs"而不是3.1中确认的部署日志,参考生产环境日志并调试错误。

### 5.5.1 本章总结

- 使用HTML5定义了header、footer、logo和body等内容的布局
- Rails的局部视图用于提高效率,可以将标记切分到单独的文件中
- CSS使用CSS类和id调整布局和设计
- 使用Bootstrap框架可以快速实现不错的设计
- Sass和Asset Pipeline为了开发效率压缩分离的CSS中的冗余部分,输出针对生产环境优化的结果
- 在Rails路由中可以自由定义规则,并且可以使用命名路由
- 集成测试有效地模拟浏览器的页面间转换
